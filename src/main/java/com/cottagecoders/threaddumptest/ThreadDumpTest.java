package com.cottagecoders.threaddumptest;

import org.apache.commons.collections4.queue.CircularFifoQueue;

import java.io.File;
import java.io.IOException;
import java.lang.management.*;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

public class ThreadDumpTest {
    private static final String JAVA_VM_NAME = System.getProperty("java.vm.name");
    private static final String JAVA_VERSION = System.getProperty("java.version");
    private static final String JAVA_VENDOR = System.getProperty("java.vendor");

    private static final int QUEUE_SIZE = 10;
    CircularFifoQueue<ThreadInfo[]>  queue = new CircularFifoQueue<>(QUEUE_SIZE);
    private final int THREAD_COUNT = 100;
    private final int ITERATIONS = 1000;

    private List<String> messages = new ArrayList<>();

    public static void main(String[] args) {
        ThreadDumpTest tdt = new ThreadDumpTest();
        tdt.doIt();
    }

    void doIt() {

        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();

        // create a bunch of threads...
        for (int i = 0; i < THREAD_COUNT; i++) {
            Sleeper s = new Sleeper(1000000L);
            new Thread(s).start();
        }
        messages.add("User Thread count after thread start loop " + threadMXBean.getThreadCount());

        // grab the thread info objects:
        long startNanos = System.nanoTime();
        for (int i = 0; i < ITERATIONS; i++) {
            queue.add(threadMXBean.dumpAllThreads(true, true));
        }

        long elapsedNanos = System.nanoTime() - startNanos;
        messages.add(String.format("gathered %d thread dumps.  elapsed times %d ns %d us %d ms total; %d ms per thread dump",
                ITERATIONS, elapsedNanos, elapsedNanos / 1_000, elapsedNanos / 1_000_000, elapsedNanos/1_000_000/1_000));

        for (ThreadInfo[] ti : queue) {
            System.out.println(threadInfoToString(ti));
        }

        // print any the saved-up output.
        for (String m : messages) {
            System.out.println(m);
        }

        // TODO: delete this - it's just some additional information:
        System.out.println(JAVA_VENDOR);
        System.out.println(JAVA_VM_NAME);
        System.out.println(JAVA_VERSION);

        //TODO: we can delete this - the delay gives us time to run commands from the shell - eg. jcmd, jstack
        // this gives the opportunity to compare the program's output to the output of jcmd.
        try {
            Thread.sleep(10000000L);
        } catch (InterruptedException ex) {
            System.out.println("interrupted");
        }

    }

    public class Sleeper implements Runnable {
        long naptime;

        public Sleeper(long ms) {
            naptime = ms;
        }

        public void run() {
            try {
                Thread.sleep(naptime);
            } catch (InterruptedException ex) {
                System.out.println("interrupted");
            }
        }
    }

    /**
     * This method "materializes" a thread dump. Iterate through the thread info objects, and print the details.
     * We can't use <code>.toString()</code> as the implementation seems to be hardcoded to cut the
     * stack trace at 8 frames - which does not serve our purpose.
     * <br>
     * <br>
     * It is expected that this method will be called
     * only when the thread dumps need to be "materialized", such as for display or to be sent to a log file.
     * <br>
     * <br>
     * The fidelity of this code may not be as good as the thread dumps that are
     * generated by <code>jcmd (pid) Thread.print</code> (for example)
     * <br>
     *
     * @param threads
     * @return thread dump
     */
    public static String threadInfoToString(ThreadInfo[] threads) {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        StringBuilder sb = new StringBuilder();
        /*the headers on the thread dump look like this:
        pid
        timestamp
        vendor and version
        eg:
        33429:
        2022-10-11 17:51:27
        Full thread dump OpenJDK 64-Bit Server VM (25.332-b09 mixed mode):
        */

        // first, a hacky way to get our pid, briefly tested on Ubuntu and macOs
        String pid  = java.lang.management.ManagementFactory.getRuntimeMXBean().getName().split("@")[0];
        sb.append(String.format("%s:\n", pid));

        sb.append(sdf.format(new Date()));
        sb.append("\n");
        sb.append(String.format("Full thread dump %s (%s):\n", JAVA_VM_NAME, JAVA_VERSION));

        for(ThreadInfo info: threads) {
            sb.append("\"" + info.getThreadName() + "\"" + " Id=" + info.getThreadId() + " " + info.getThreadState());
            if (info.getLockName() != null) {
                sb.append(" on " + info.getLockName());
            }
            if (info.getLockOwnerName() != null) {
                sb.append(" owned by \"" + info.getLockOwnerName() + "\" Id=" + info.getLockOwnerId());
            }
            if (info.isSuspended()) {
                sb.append(" (suspended)");
            }
            if (info.isInNative()) {
                sb.append(" (in native)");
            }
            sb.append('\n');

            int i = 0;
            for(StackTraceElement ste : info.getStackTrace()) {
                if (i == 0 && info.getLockInfo() != null) {
                    Thread.State ts = info.getThreadState();
                    switch (ts) {
                        case BLOCKED:
                            sb.append("\t-  blocked on " + info.getLockInfo());
                            sb.append('\n');
                            break;
                        case WAITING:
                            sb.append("\t-  waiting on " + info.getLockInfo());
                            sb.append('\n');
                            break;
                        case TIMED_WAITING:
                            sb.append("\t-  waiting on " + info.getLockInfo());
                            sb.append('\n');
                            break;
                        default:
                    }
                }

                sb.append("\tat " + ste.toString());
                sb.append('\n');

                i++;

                for (MonitorInfo mi : info.getLockedMonitors()) {
                    if (mi.getLockedStackDepth() == i) {
                        sb.append("\t-  locked " + mi);
                        sb.append('\n');
                    }
                }
            }

            LockInfo[] locks = info.getLockedSynchronizers();
            if (locks.length > 0) {
                sb.append("\n\tNumber of locked synchronizers = " + locks.length);
                sb.append('\n');
                for (LockInfo li : locks) {
                    sb.append("\t- " + li);
                    sb.append('\n');
                }
            }
            sb.append('\n');
        }

        return sb.toString();
    }

}
